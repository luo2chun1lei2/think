# Think

描述一个系统的关系的方法，可以快速的建立模型，和针对需要找到解决方案。

## 关系的观念

### 目前的系统

现在的所有的系统主要是通过描述“如何实现”，比如系统的初始化步骤，
系统的运转步骤，但是初始化为什么样的模型，以及模型中各个模块之间的关系，
这些都需要使用者自己去探索到底是什么关系。

比如说，当a初始化为5时，b需要设置为25，当a加1时，b需要加11，虽然实现的步骤有了，
但是并没有说a和b到底是什么关系，虽然它们之间的关系很简单：b=a^2。

开发程序的时候，程序员一般是现将整个系统划分成尽可能独立的模块，然后建立模块之间的关系，
以及每个模块内部的元素的关系。建立关系后，就会将关系转化为动作，比如从空无所有如何建立一个初始化的状态，
然后当外界或者内部的元素发生了变化后，那么怎么维护这个关系。

上面的例子是 b=a^2，假定a最开始是1，那么b也是1，这就是初始化状态，当外部改变了a的值时，那么b应该变成什么才能保持这个关系？
这就是程序员需要去编写的“实现步骤”。

实际上，如果在深究“实现步骤”，会发现其实它们许多描述的也是关系，比如一般编程的时候，不会这些编写：

```
switch (a) {
    case 1:
        b = 1;
    case 2:
        b = 4;
    ...
}
```

而是直接写

```
b = a*a;
```

所以程序员如果可以用关系表述元素之间的关系，就会用“关系”来表述，而不是偏向于更加底层的实现。
之所以用底层实现的原因是：

* 语言或者工具没有强制要求。
* 系统中的关系总是模糊、随意的，尤其是涉及到社会关系方面的，所以无法用简单的、固定的关系来描述。
* 因为涉及到其他模块，这些模块就没有提供关系的描述，所以只能按照实现的步骤来编写。

### 需要关系

“动作”的特点是：

1. 最基本的元素是“动作”，参考汇编语句，动作是“做什么”，比如“比较两个寄存器中数据的大小，然后将结果放到某个寄存器去”。
    所有的动作都有一个具体的结果，大部分有一个前置条件。
1. 这些语句按照设定的顺序执行，也有改变顺序的动作，比如 `goto/for/while/if/switch` 等。
1. 还有一种是触发或中断情况下，会导致某些动作突然发生。
1. 动作不仅仅是维持原先设定的关系，还可以改变关系，当某些条件符合后，触发的动作会改变当前某些关系为其他关系。

开发人员需要根据系统的关系，转变成能够实现的动作，然后再通过这些动作综合成形成了什么关系，和之前预定的关系比较，
检查是否有疏漏。

“关系”的特点是：

1. 它描述的是对象和对象之间的联系，实际上由底层的动作来实现。
1. 关系和关系和组合成新的关系。

如果一个系统采用关系来描述，那么它将带来如下的好处：

* 关系比实现步骤更加抽象，能够让用户和开发者理解，可能会不够直接。
* 元素与元素之间的关系能够非常清楚，而不用总是从具体的步骤去总结。
  也更加简洁和直接的体现系统内部的结构。

预计问题：
* 层次越高的描述，可能可以重复的部分越少，导致每个具体关系都需要定制。
* 和外部非关系、有关系缺陷的模块建立联系后，发现无法整合成为一个整体。


