# 思考 Think
---

【我思故我在，我在故我思。】

## 需求
---
---

研发一种工具，可以辅助思考。

我们在思考问题的时候，大部分集中在三个方面：观察、分析和影响。
观察是研究事物的表现，不过随着分析和影响的深入，会重新观察目标，甚至观察其他的目标。
分析是在观察的结果上，用科学的方法去归纳和解释事物的运行的规律，当然这些规律可能只是其中的一种解释，甚至可能是错误的，只要部分符合就行了。
最后是影响，大部分情况下分析得到的规律会有很多，那么仅仅是隔离在研究目标之外，是很难搞明白到底哪种规律才是正确的，
何况有些情况下，观察者（我们）也处于和研究目标在一起的情况。所以需要在规划好的影响下，重新进行观察和分析，得到更加准确的规律。

本软件重点在分析，它通过 **描述事物的关系**，形成抽象的“对象-关系网络”(Object-Relaion Network)，然后再针对这个网络进行研究。
因为分析本身必须符合逻辑规则，所以针对关联可以进行分析，而且可以提高观察者的分析能力。

## 需求分析
---
---

【根据上面的需求，抽象、完善、精炼需求，形成符合逻辑、完整、完备的需求说明】

【关系在这个工具中是核心。】
我们目前使用的程序，是建立在“函数”(function)为基础的软件系统，而函数体现的是“动作”(action)。
这些函数会根据输入改变或查询系统各个部分的状态，要求是无论怎么改变后都需要保持系统的各个部分状态的一致性。
它们的流程是，当“触发”(Trigger)被引发后，一个一个函数调用起来，改变系统的各个部分，直到相关动作完成。
所以函数的核心是建立系统内各个部分的“关系”，只是这种关系大部分是函数表现出来的，而不是明显的设定。
这个工具就是想翻转这种情况，先“描述关系”，然后再自动的、可定制的使用动作来实现关系。

【描述是什么，而不是如何、怎么做】
既然是“描述关系”，那么核心是描述，而不是具体的说明以何种方式实现，而是静态的说明关系如何。
知道了关系后，根据预先设定的步骤实现这个关系，或者允许定制这种关系的实现。
所以关系可能是一个，但是实现这个关系的会有多种，选择其中一种就行了。

【描述的核心是关系】
之前说程序的组成是“数据”和“算法“，在这里描述的核心是“关系”。
关系本身也要能够组合，才能描述从简单到复杂的事物。
为了形成这些关系，需要一套接口建立关系。然后按照关系分析系统。最后，运转这个关系，实现它描述的系统。

用户需要的功能：
1. 可以设定对象的关系，并显示关系图，并进行修改等操作。
	比如将关系图显示为 graphviz 图像。
2. 根据关系图，可以查询。
	比如 查询一个函数的调用关系，并且找到其中包含“rpmb”的字的函数。
3. 根据关系图，可以建立实际的系统，并运转起来。
	比如 建立数据组，然后显示在List表中，可以进行查询和修改。
4. 隐含包含关系图可以保存和恢复，以及用业务语言进行扩展。

### 先给一个简单的要求
---

1. 可以进行单元测试。
2. 可以单独运行。
3. 接受简单的输入和输出。
4. 能够有复杂的输入和输出。
5. 支持不同模型的切换和处理。
6. 具有图形画面。

【现在偏离了使用，目前最要紧的是制作函数调用关系，以及模块包含关系图，其他的功能如果没有用到，就先不要实现。】
逐步负责 + 可以使用

### 想实现的实用功能：
---
	1. 任务列表、说明列表等。 【简单实现】
	2. 函数、模块之间的调用关系图。 【简单的实现】
	3. 模块、包、系统之间的关联关系图，比如依赖、调用等。 【简单的实现】
	4. 查询和分析。【<-- 要实现表达式，需要重新规划整个语言语句！】
	5. 运行关系。

## 系统的理论
---
---

【设定了基本的需求后，要创造一种新的理论，或者用已有的理论来设计系统。】

### 核心概念
---

【对象、关系、动作、运转】

1. 对象(Object)，是系统中概念的最基本类型，关系约定的是对象(Object)。对象是个“标记“事物，是关系影响的目标。
    它不需要复杂的功能。
	1. 需要一个名字，用来标明自己，在不同的区域中可能会避免重名，或者有特殊的字符要求。
	2. 允许指向多个关系，这些关系都是和此对象有联系的。
2. 系统的核心是关系（Relation），用于描述多个对象之间的联系，而且关系本身也是一种对象。
	1. 关系不是函数（function），函数是动作，可以建立、删除、修改“关系”。
	关系是**描述**语句，描述系统内对象之间的联系。
	例子，`a+b` 的 `+` 是动作，因为 `a` 和 `b` 之间没有关联，当一个数值发生变化时，另外一个没有任何影响。
	    但是 `a=b` 的 `=` 是关系，因为 `=` 指明 `a` 和 `b` 之间的关系，当 `b` 发生改变后， `a` 也需要改变，才能保证关系成立。
	    `c=a+b` 的 `=+` 则是关系，因为它指明了 `c` 和 `ab` 之间的关系。
	2. 关系必须指向多个对象，建立这些对象之间的关系。
    3. 关系涉及的对象，不一定是所有的对象都适合。关系可以挑选适合的对象，比如 `c=a+b`，那么`a/b/c`都必须是可以获取和设置值的才行！
    4. 根据关系可以得到不同的对象组，这些可以用”延迟获取“的方式来设定。
      比如:和a相关的对象形成的集合， 转变成关系 `和a相关的对象(set, a)`，那么 `set` 就是虚拟的对象，它可以提供对外的”迭代子“，然后”迭代子“根据关系生成的规则来遍历 `a` 的关系。
	  当然也可以制作 `set` 内部的集合，这样就比较消耗内存。
	5. 关系最好建立一对一的关系。那么就需要一个对象的关系的名字可以重复。
      	1. 比如 我的叔叔是A和B，A的侄子则是我和张三，那么关系不能重名，就只能变成一个关系对多个对象，
		  这样关系图怎么形成？ 所以目前看只能是一对一的关系是最好的选择。
3. 动作可以建立关系系统，是基于对象和关系的网，称为”对象关系网“(object-relation network = OR-Net)。
    1. 动作是一些步骤，每个步骤是做一些事情，比如改变关系等。
    2. 根据对象和关系设定，是不允许 `O->O` 的连线存在。
	6. "对象关系路径"(OR-Path)，是基于对象关系网的一个路径标志方法， x.xx.xxx，就是根据x找到它的关系，然后再根据xxx找到关系的对象名字中符合的。
	   如果关系涉及的对象只有一个或者没有名字，可以忽略继续找下一个关系。【这里定义不够明确】
	4. 关系必须支持可以“组合”，就是通过对象和关系组成更大的对象或关系。
4. 根据关系可以进行查询、判断和分析。就是在OR-Net中找到符合条件的对象，或者根据符合条件的对象，建立新的关系。
	另外，将**推理**方法用于关系分析时，能够得到更多的关系，虽然本质上知识的总量并没有变化。【推理，还需要再研究一下】
	1. 关系中的某些条件符合时，也可能引发设定动作的运行，建立新的关系。 【如果 condition，就 action】
	动作 -> 关系 -> 动作 -> 关系 ...
	2. 关系不仅仅可以用来建立系统的某个状态内的各个部分之间的关系，实际上也可以建立不同状态之间的关系，就是关系的关系，只要是研究的目标就行。
5. 系统在定好的关系中，也可以按照关系进行运转（perform，不用运行"run"这个词），这就能够将此系统应用在实际的项目中。
	比如 `map(from=data, to=display)`，这样如果实现了`map`后，那么当data改变后，就会改变display了。
	1. 运转有两个实现方法，一个是 map 等relation 内部有特定实现，当涉及到的对象发生变化后，就会运转起来，需要建立的是“影响延伸算法”。
		另外，从外部建立算法，用 visitor 模式来实现，实现隔离算法和关系图(OR-Net)。
		【应该用第二种！】
	目前需要考虑复杂的OR网时，关系的运转问题！比如复杂的公式计算，目前希望用观察者模式解决这个问题。
	`改变 -> 联动 -> 求值 -> 改变 -> 联动 -> 求值 ...`
	希望建立简洁、完备的逻辑。
	2. 运转有两种情况，一种是整个系统运转起来后，当一部分对象发生变化后，引发了其他的对象发生变化。
		每种变化都是由自变量(variable)决定的一个系统状态(state)。
		对象的状态(object state)是对象本身的属性相关的一个设定集合。
		还有一种是系统没有运转起来时，查询查询某个对象的情况，比如庞大的运算公式系统中，求一个对象的状态。
		这是一种偏运转(paritial perform)，先根据想要的结果得到需要，然后在需要满足的情况下，
		算出部分OR-Net的状态。
		【庞大的系统，可能需要第二种情况！】


## 设计
---
---

因为这个是尝试性的软件，所以主体采用循序渐进的开发方法，每一步都要简单、可以测试、有一定的实用行。
下面是从不同的方面来总结软件的功能都有哪些，按照从简单到复杂的方向添加。后面会根据这些功能进行组合成工程进度安排。

功能的多个层次：
第一层是关系的核心数据结构的建立。
第二层则是对关系数据结构应用查询、推理之类的，可以扩展关系的描述，让关系可以描述更加复杂的系统。
第三层根据关系来运转系统，这个就可以应用到真实应用场景中了。

应用分成三个部分：
第一部分是作为最核心的数据结构和增删改查接口。
第二部分是数据结构外层的容器和应用接口，比如输入、输出模块，还有外部的语言，可以不止一个。
第三部分是扩展部分，仿效libc库和Java的类库，允许用内部模块、外置模块、业务语言进行扩展。

### 功能设计
---

可以按照关联关系进行系统运转。
	`动作    -> OR关系网 -> 运转`
	`Action -> OR-Net  -> Perform`

#### 核心的建立

设计下面的参考prolog语言的做法，此工具需要实现的功能。

##### 描述和动作

【这里需要解释何为“动作”，何为“描述”】

##### 对象+关系

1. 对象(Object)是所有对象的基类。
	有一个name。【一个元素的关系可以在元素的范围内重名，比如我的朋友可以是多个，也可以单列，这个问题怎么办？属于R的重名】
	特化的元素：
		1. 值类型，内部是一个值，比如字符串、整数、浮点数、布尔值等。主要用于计算和文字处理。
			这里要分清，程序需要描述的是“关系”，关系主要是变量，就是在任何情况下，都需要维持的一个关系，
			只有在关系本身就包含常量（比如字符串、数字）时，才需要这个值。
			等到关系建立后，系统根据关系运转起来时，才会给变量赋值，然后按照关系影响其他的对象！
			值还有一个子集，就是常量，数值是固定的！
			比如 c=a+5，5是关系中的常量，而c和a都是普通的变量。
			【计算或文字处理，需要一个共通的接口，就是value、string！】
			是否可以认为所有的元素都可以获取值（是字符串），然后再根据公式强制转化为数字之类的。
		2. 关系，指明多个元素之间的关系。
	比如:
	```python
	// e0是程序内的名字，后面是此元素的具体属性。
	// 具体属性是值: e0 的年龄是43。
	e0 = People(xingming="luocl", old=43, sex="male")
	```

	一个元素可以拥有任意的属性(property)，这些property都有值，值可以是任意的元素。
	属性(property)或者标签(tag)都相当于一个 a--r-->b 的关联。
	比如说 a的属性r，那么就是说 “a的关系b对应的元素”，这里就是b了。

2. 元素延伸出关系(Relation)，关系可以关联多个元素。一个元素可以通过关系关联多个对象。一个元素可以有多个关系。
	【关系的名字（不是类型）必须是唯一的？那么就需要R必须有一对多的实现。】
	a--r-->b : a和b之间有关系r，a的r是b（这种称为关系的属性描述方法）。
	```python
	// 可以设置e0和e1的关系为r1，e0和e2的关系也为r1
	// 等号的右边是自变量，左边是随便量，就是当自变量发生变化后，随便量需要跟着变化。反向则不同。
	e0.r1 = e1, e2， ...
	```
	等同于
	```python
	// 【怎么知道是relation还是普通element，或者是不需要区分？】
	r1(e0, e1)
	r1(e0, e2)
	...
	```
	现实中的例子：
	```
	我.侄子 = 小多, 小豹
	```
	【下面的想法，有待再确认和修改】
	* e0可以是表达式，只要最后的结果是一个必须已存在的元素。
	* r1可以是表达式，最后的结果只要是一个“文字”，这样就可以创建一个新的relation。
	* e1/e2可以是表达式，如果结果是一个必须已经存在的元素，那么就设置到r1中。如果结果是一个值，那么就创建一个新的元素。
	* 关系是有方向的，可以单向或者双向的。比如 我和小多是亲戚，“亲戚”就是一个双向的关系。

3. 对象和关系的类图设计：
+---------+
|         |
\/        |
O <|----- R
|         ^
|         |
+---------+
   可能的联系: `O->R 或 R->O 或 R->R`，`R->R`是允许一个关系也有自己的属性等关联关系。关联关系并不是说一定是值的关系。

##### 动作+函数

为了建立关系模型，需要有“动作”，动作就是描述“干什么”，这样就可以搭建一个关系模型。
和其他程序的区别就是：动作建立的是关系，不是只设定最终的结果，
比如:
```python
s = a+b+c
```
一般的程序是将三个数字的和赋值给s，之后s和a、b、c之间的关系就无法看到了，除非看到代码。
而此语言则是保留`s=a+b+c`之间的关系，之后等到a/b/c发生变化时，s会跟着计算。

1. 单个动作:
```python
r = R(x=1, y=2, z=3)	# 建立
r.x = 100		# 修改
delete(r.y)		# 删除
ask(r.z)		# 查询
```
通过类型来新建一个元素，或者就是一个动作。【这里假定动作就是一个“建立元素”，不知道是否可以？】

2. 表达式
多个元素和关系可以形成一个组合元素(combined element)，此组合元素对外的关系就是内部所有元素对外关系。
当然，多个关系也可以组合成一个关系(combined relation=combined element)。
可以将关系和元素组成一个有意义的组合，形成一个“组合对象“，这个就是表达式。

表达式是各种元素的有效组合，可以是(等号右边的)
```python
	expr = a
	expr = a.b
	expr = (a + 3) / 2
	expr = (a.b + 3) / 2
```

还有分支和循环逻辑语句
```python
	if (a == b) {
		sum = NAN;
	} else {
		sum = a/(a-b);
	}
	while(expr) {
		...
	}
```
这个和后面的关系中的循环逻辑和分支是不同的，因为这里的判断和循环是不保留在“关系”中的。

表达式用另外的更加通用的描述方法【不要，这样太奇怪了，还是用平常的书写方法最好。】
```python
	expr = /( +(a.b, 3), 2)
	expr = f1( f2(a, b), c) # 更加的通用！但是不符合一般写法。
```

3. 多个动作成一个函数
```python
f = Function(a, b, c) { # 定义
	a = ABC(a, b, c)
	r = R(d, e, f)
}
f(x, y, z)	# 调用
```

##### 类型

这里的类型是说“关系”和“对象”在系统中的分类，参考C、Python等的实现。
首先，类型在编程语言中的作用目前有两个，一个是根据类型可以生成肯定符合要求的实例，
这个实例有必须的属性和函数接口，这样系统才能运转功能。
第二个是身份识别，可以识别这个实例是否符合要求，容纳数据和执行功能，另外也可以纯粹用于身份的识别，
不过身份的识别还是用于系统的运行。

根据上面两种情况，得到类型的两个重要点：【都可以是动作或者描述】
1. 约束/核对：约束是描述，系统根据描述来检查。而核对则是一组动作，检查对象是否符合关系要求。
2. 模板/工厂：模板是描述，系统根据描述制作实例。而工厂则是一系列动作构造出一个对象。
2. 关系分类，是按照 Relation 的类型，还是Relation的名字 ？
	【应该按照类型！ 名字只是形成了"名字路径"(name path)!】

自定义模板和自定义约束（或者称为接口）。

1. 模板：可以从此模板衍生其他的模板，或者元素。
	这样就不用每个对象重复设置关系，这样对于关系来说，可以设定某一类型的关系，而不再是某个具体的对象的关系。

	```python
	ABC = Relation(a, b, c)
	{
		c = a + b
	}
	abc = ABC(1, 2, sum) # 设定了 sum 和 1、2 的关系。
	```

	```python
	# 这个是新的元素，设定了一个元素。
	DEF = ABC(old, height) {
		self.old = old
		self.height = height
	}

	```python
	# 模板之间的继承
	XYZ(weight) = ABC(old, height) {
		self.weight = weight;
	}
	```

2. 接口，可以用于“检测匹配”，比如接口，凡是符合这个接口的，就都可以用。
	
	如果是接口的定义，必须从Interface继承：
	```python
		abc = Interface() {
			father; // 必须有的属性
			mother;
			r123(father, mother); 	// 必须具有的关系
		}
	```
	接口可以用于检查某个元素是否符合要求！

##### 组合

组合：多个关系的组合下，形成新的关系名称。 `r1(a, b) & r2(b, c)  则 r3(a, c)`。【类似类型】
	组合可以有两种表达方式，一种是关系就是组合后的对象，比如目前程序分析中的语法树就是这样。
	另外一种是预想的更加广泛的关系模型，就是组合后的也是一个对象，然后此对象再通过关系和其他对象相关。
	目前看比较成熟的是“第一种方案”。


##### 衍生关系  【这里应该是衍生、组合和约束等 TODO 没有写】

衍生：通过推理，得到其他的关系`(a->b->c := a->c)`。或者在某些附加关系下，推导系统中关系情况。(if a==0 := c=b)

在逻辑判断中，会出现“如果……就……“的逻辑，那么需要这样定义
```python
	sum= { 1 if a==b; sum=a/(a-b) else };
```

```python
	sum= { if n > 100 in n : Numbers }; # 数字中，大于100的。
```

上面的关系是在条件的基础上建立的，所以是“衍生”的关系。
和之上的关系不同的是，以上的关系都会记录在关系中，之后都会对系统产生影响。


#### 扩展层



##### 扩展

原有的关系是无法和实际的关系一一对应的，那么扩展后的对象，如果无法复制和约束，将无法在实际的大工程中应用，
所以这里需要实现必须的扩展： 【这里写和具体实现相关的设计要点。】

##### 关系模型

关系模型这里作为一个在语句、函数等之上的一个高级元素，可以提供给其他模块来使用。
和普通程序类似，此程序允许建立独立的关系模型，就相当于程序中的静态/动态模块，不同的是这里是逻辑单位，而不是编译好的实体单位。

1. 推导：从已有条件，得出一个非内在的结果，是推导条件。根据推导条件推导出需要查询的结果。【其实推导也是在建立新的关系，当条件成立的时候】
	可以参考“prolog的推理公式”，就能将逻辑组合出来：符合条件，就能达成什么情况。达成什么情况，就会出现必要条件。（充分和必要条件）

	推导描述的是`a == b`成立时，得出`c=1`，否则“c=a/(a-b)”。
	```python
	c=1 :- a==b; c=a/(a-b) :- a!=b;
	```

##### 模型之间的关系

本章描述多个模型之间的关系。
问题的提出是，因为以后开发必然需要将程序切成不同的组，这些组之间肯定也需要关联的，这个就是描述这个层次的关系的。

#### 运转层

主要按照实际的系统模块来形成 OR。
这里涉及到日志、显示、数据列表。

##### 模型的运转

对象关系网（OR-Net）建立后，就可以运转起来(perform)，这个不是动作(action)。
动作是建立对象关系网，而运转是按照关系网的设定，系统运行起来。
举例子来说，
  “动作”添加各种对象和关系，建立了简单的关系网"x=(y+z)/3"。
  然后关系网运转时，给y和z赋值后，x就得到结果。
  “动作”添加了一个对象，内部有复杂的关系图，然后建立一个Graphviz的对象，
  建立“show”关系关联两个对象。这个时候，包含多个对象和“show”关系的图就建立。
  系统运行的时候，show会将第一个对象的内部的关系告诉Graphviz对象。
  Graphivz对象就会显示出关系的图。如果对象的内部关系发生变化后，那么show会通知Graphviz更新，
  这样就保持了两个对象之间的show关系。

### 应用设计
---
这里谈一下，此应用应该如何实现，核心不是OR-Net，而是程序的组成，尽量做到之后容易扩展和修改。

#### 人机接口

总起讲一下，应用设计最核心的人机接口问题，然后具体实现规划到不同的部分和层次。

1. API函数。
2. 脚本可以调用API函数，特点是必须按照循序执行，才能得到正确的模型，所以里面有 if、for等。比如现在张三结交李四。
	它的本质是通过执行语句，来构造出一个模型。
	正则表达式的脚本（regrex），和高级的语法脚本（Flex+Bison）。
3. 关系模型的描述文件。静态类型的结构描述，不是执行的，从任何顺序读取都能够恢复成正确的模型。
	要求描述语句是静态的，而不是动态的。比如张三是李四的朋友。本质上，它就是模型，至于怎么构造，程序自动完成。
4. 模型数据的DB数据保存，以后用于数据保存和重现。

#### 对象容器

讨论应用如何实现容纳 `对象关系网` 的容器实现方法，以及对外的接口。

#### 应用

讨论组成应用的各个模块，比如输入、输出、控制模块。

外部模块设计，分成应用、输入、输出、控制等，但是最难也是最重要的是 **语言设计**。
下面将通过逐步的步骤来实现当前的系统的“语言”级别描述方法。

注意，语言设计到两个部分，第一个是描述关系，第二部分是建立、修改、删除、查询关系的动作，
这两部分要明确，动作在这里也非常重要，因为关系必须建立才能有。


#### 扩展

讨论如何允许外部扩展应用、容器等部分，怎样就可以在实际中运用。

## 实现和接口
---
---

【满足要求的最简洁的实现，才是最好的实现。】
这里讨论和实际实现相关的特点和注意点，不再包括上面设计的部分。
### 代码结构
---

1. misc 是多种工具，可以供其他的层使用。是最底层的、不能对象化的模块。
	比如基本日志输出等。
2. native 层，用于保存各种功能的底层实现，供 Object和Relation 使用。
	之后有可能会化为对象或relation。
3. core 是核心，Object+Ralation数据结构在这里，以及相关的模块。
	比如 `Object、Relation` 等类。
4. ext 是在core的基础上扩展的各个Object和Relation的子类，主要支持各种语法和规则，形成语言层的OR-Net。
	比如数学计算、文字处理、表达式等。还有 `运转` 相关的。
5. fwk 集成Object+Relation的扩展模块，主要是构成应用程序，所以大部分是和操作系统、画面等相关的模块。
	比如显示、日志、流程处理等的object、relation。
6. app 非Object+Relation的模块，用于建立的主程序和测试程序。
	必须程序启动、命令或脚本分析。还有 `动作` 等。

### 设计实现的步骤
---

本软件的基本流程：
	1. 管理语句（描述语句+控制语句） -> 关系模型 -> 输出
	2. 输入 -> 处理 -> 关系模型 -> 处理 -> 新的关系模型 -> 输出

L1. [简单] <-- 在做：
	1. 构筑了简单的Object+Relation（）。
		1. Object + Relation（）。
		2. 允许建立简单的 算数计算（），画面显示（），日志输出（）。
	2. 需要加入输入和输出。现在脚本的语法还没有确定，要按照上面的具体应用来设计。()
		1. 先按照最简单的行分析来进行（）
		2. 按照C、Python的简单子集来实现。()
	3. 在main函数中设定输出和输出。作为脚本可以输入，但是没有实现交互模式，以及输出。()
		1. 我想做到Model中无论哪种关系，怎么建立起来的，都可以输出成脚本，这就相当于关系模型的保存功能。()
		2. 首先所有的高级模块，比如model/process之类的，现在用代码固定，后面将用注册的方式，这样可以通过任意组合来实现不同的功能，现在还没有必要。()

## 测试和问题
	1. 对象和关系的设计过于复杂，在实现和分析时非常麻烦。

## 任务清单
1. 实现简单的应用，比如函数调用关系图，以及数据结构的关系图。
	1. Relation 有from和to，然后对象同名的关系是一个关系。
	   所有的关系要根据自己的功能，确定from和to能够设定的数目。         OK
	2. Output 需要设定关系后，能够根据设定显示结果。【需要独立的线程、进程？】
	3. 将 Input/Process/Model/Output变成对象，然后建立关系。            OK
	4. Object/Relation 无法应用到不使用OR-Net的环境，这个是否需要？
	5. 可以组合对象，这样可以实现多个对象合成的功能。
		1. 组合也用OR-Net来实现。
		2. 等同于一个对象或者关系，可以作为一个整体来使用。也可以看到其中的结构。
			也许Model就是一个组合对象。
2. 将OR-Net保存在永久存储中，然后可以恢复回来。目前想定是SQLite。
3. 实现函数，以及工厂模式，可以创建特定类型的对象。
4. 由工厂模式，实现可以描述的模板，然后系统自动根据描述形成工厂。
5. 实现约束，可以检查某个对象符合类型的描述。
6. 实现简单的外部脚本。
7. 实现通用查询的功能。
8. 实现具体的对象，可以和DB和画面链接。


## 零碎的想法
---
---

零碎的想法，先记录在这里，之后合并到前面对应的篇章。
### 对语法的想法

目前纠结在语法的规定上，不要再在单行的命令语法上徘徊了，需要深入到高级语法上去。
1. 用 TAG 描述是否很快，很直接？ a.b = c，b是关系名字，a的b是c，也意味着 a和c之间的关系是b。
	比如 我的名字是张三，那么我和张三的关系是名字。
2. 用 自然语言来说，“主谓宾”是最核心的语句，那么每个部分都可以加入定语或者副词，也就意味着标签/属性。
	另外“介词”怎么考虑？
	
另外一种是按照prolog方式，用括号来表示，比如 R(a, b)，以及设定“规则”，这个其实都满足目前think的需要。
	但是prolog语言本身是服务于逻辑推理的，并不是用来编程，无法满足目前编程的需求，因为目前编程都是基于“动作”的，
	没有固定的规则，只有客户的想法，只有当出现现实的冲突时，功能设计才会分析冲突的原因，指定统一的规则，否则是不管的。
	所以现在的语言重点是实现，而不是推理！
	【这个也是我目前制作think时的最大困惑地方，如何在普通编程中用到关系推理？】

语法中是否可以提供一个造型能力？就是通过简单的记法，转变为正规的关系描述，这样可以缩减描述的大小，以及提供高级扩展功能。

建立更加高级的表达式机制：

Query value=表达式
表达式类似于 c 语言的表达式。

### 系统的设计的新思路：
1. 系统如果想运转，那么就会改变每个对象的状态，比如是变量的改变值，是数据模块（比如JavaBean）的改变数据模块内的变量，
	如果是某种实例引用的话，可能传递的是实例的指针。等等情况下，实际上可以将系统的OR-Net分成两层。
	1. 第一层是由 object-relation 组成的网络，但是object和relation都是一个空壳，只有名字和种类是需要的。
	2. 第二层是在运转中产生的数据或实例，挂在上面的object或relation中，
		在运转过程中还会不断的根据relation的要求和object的变化来改变 object-relation 的持有物。
	综合起来，结构就是 object -> value, Travel all objects to perform.


### 对于系统的动作和关系的想法
动作用于建立关系网(OR-Net)，但是动作本身也可以看做是一组对象，只不过按照顺序执行，
那么函数也可以看做是一组关系的组合。

这里不要搞混了，函数本身的关系和最后形成的OR-Net是不一样的。
比如说，函数中一个变量，需要根据类型来判断，然后它只是一个变量，内部可以含有一个或就是一个对象。
而OR-Net则纯粹就是Object组成的图。

最后，系统在后面的发展下，有可能出现关系网和动作对象混合的情况，这样就需要严格的区分两种不同的网，
以及他们的作用，虽然后面有可能越来越模糊。


### 自描述

作为对象，有哪些属性，已经属性的说明和相互关系是什么，这个可以由对象自己提供。
然后使用此对象者，可以根据这些描述“自动”的使用。
这个相互约定，就是自描述，只描述不运用，实际上没有什么大用。

### 唯一、可见 和 权限
先讨论唯一性、可见性、权限和引用。
程序无法做到“绝对”唯一性，只能在某个区域，比照是“C++的命名空间”。
在这个区域中，所有对象的ID是唯一的。

可见性也是基于区域，区域内对象可以对外可见，也可以不可见。
然后由其他的区域引入可见。

可见还可以动态或者静态的，静态的是编译时间的，动态是运行期的。
因为此工具目前是“脚本”，所以应该都是动态的。

权限是基于对象功能的“权限授予”机制，
	首先要将对象的功能进行划分，分成不同的种类和级别，高级别的可以控制低级别的。
	然后在系统初始化时，将功能按照“可见”分发出去。
	最后系统运转时，得到权限的对象可以使用这些权限。
	具体的权限策略，需要使用者自己在规定的范围内（很灵活的），自行配置。

程序内部肯定是要求确定每个对象的唯一性，有两个选择，一个是用“指针”，另外一个用“唯一ID”。
	指针是临时的，而且无法永久保存和从保存中回复，所以只能用“唯一ID”。
对于使用者，用ID号，实际上很难使用，因为不够直接，可以用“名字”。
	名字就如同变量的名字，可以容易理解。(没有看到名字的必要性)
另外一种方案是，如果使用者给出了名字，那么就用，如果没有，就生成一个ID作为名字。

类型不是名字，它是种类，必须符合一定的要求才可以，比如有哪些属性，或者可以执行什么方法之类的。
名字是标记，是为了区分其他的对象而定的，可以根据名字找到对象，然后使用。

问题：关系是有方向的，那么 我 打 他，和 他 打 我，中的“打”是不同的，因为方向不同。
	那么如果关系不允许重名，这种情况怎么办？

### 属性
属性可以这样设定，关系是“属性”类型，然后目标对象的名字是name，值是value。
这样 `value = a.name`。

不过问题是如果属性有多个时，比如我的叔叔是a和b，
那么 `我.叔叔` 怎么办？可以将属性设置为多个。
`我 --> 属性 --> (name=叔叔, value=a) & (name=叔叔, value=b)`
无法形成有效的关系网。
所以可以是:
`我 -- 叔叔 --> a`
`我 -- 叔叔 --> b`

总结一下，Path可以有两种分割符号，
"." 是说属性，那么 a.b = a的关系的唯一对象，
用"->"作为Path的指引，那么就是完整的关系指引,
“*”表示求对象的值，没有的是关系。

### 指令
指令也是对象， intructation : object
然后 指令聚合在 executor 中。
最后，executor 里面有 environment，负责环境。
MainExecutor作为缺省的启动指令。

以上都是关系网OR-Net，然后Processor运转整个关系网。

### 怎么区分关系和对象
关系是一种特殊的对象，关系主要是描述多个对象之间的联系，这个联系必须是
1. 依照功能需要的，并不是开发人员随意添加的临时的、过渡的联系。
2. 非临时的，在系统没有发生变化时，不会改变联系。
3. 当其中一个对象发生变化后，关系会维护维护之间的联系。
4. 其他的非关系对象，都是独立的，无关其他对象，只关心自己。
   比如显示系统，只关系显示送入的关系图，而不需要维持和其他的对象的关系。

### 关系要区分“from”和“to”
能区分 from 和 to 是关系必然的情况吗？
1. from是自动量，to是从动量。一个对象有没有可能即使from，也是to ？
2. from 和 to 都可以是多个。

### 语言的思考
语言抽象阶段：  读取 -> 转换 -> 执行
编译语言： 读取 -> 转换成二进制机器码 -> 运行机器码
脚本语言： 执行 -> 读取 -> 调用对应的接口 -> 运行
Java语言: 编译 -> 读取 -> 生成二进制中间码， 执行 -> 将“中间码”转为机器码 -> 运行

我们的语言是：
执行 -> 读取脚本 -> 调用对应的接口 -> 运行
所以我称语言中的类型为“脚本类型”，以及其他的“脚本函数”等，
和此程序中为了实现而编写的“类型”和“函数”进行区分。

OR-Net中的对象不是固定值，是描述抽象关系，讲述相互之间的约束和生成方式。
具体值的设置，需要在perform时设置，然后就可以了。

### relation 的思考
relation是两个对象之间的关系，可以是运转的，也可以是逻辑的，还有可能只是一种描述。
另外，为了将object 和relation之间区分开，以及将他们的接口都固定化，就需要一种标准的接口，
那么我设定为 “Model” 为标准接口，所有的对象获取和发送的，以及关系获取和发送的，都是 Model。
而model中则是一个对象列表，包括一个OR-Net，OR-Net中只有在Model列表中的对象才有用。
（或者复制出重造后的OR-Net，Model也是一个对象）
关系需要根据“主动对象”来得到model，然后将此model传递给目的对象。

需要快速建立可以应用的think，而不是光在概念上兜圈圈。