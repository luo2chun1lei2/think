# 实现的思路
1. 所有可以建立的目标称为对象。
	1. 关系是一种对象，它可以指定对象之间的联系，并维持。
	1. 关系内部由映射完成。
1. 映射是：当一个对象发生了变化后，可以通知另外一个对象。
 	1. 通知的数据：目前是基本的数据，不是一个对象，因为考虑到这里需要最基本的功能，
 		所以就建立了比对象更加底层的数据类型。
 		TODO 这里可以讨论，如果传递的也是一个对象会怎么样？对于计算或者显示等操作来说，
 		最终还是需要基本的数据，这个目前无法改变。
 	1. 传输数据的具体设计
 		1. 数据是如下的考虑：
			1. 一个模块如果对外是透明的，则会提供一个接口来返回内部整体的数据结构的一个复制，外部可以对此数据进行修改，
			 但是并不影响此模块内的数据，同样模块内如果数据被修改了，也不会影响已经传出的数据结构。
			 以上结构，对于复杂系统并不合适，复杂系统中，数据结构必然庞大，怎么可能制作整体的复制，则效率会很低。
			1. 另外一种模式，返回的也是内部的对象，则这样外部的对象体系也可以看到这些对象，并建立关系，
				 这样适合复杂或者庞大的系统。
		1. 变化有：
			1. 应该建立对象与对象之间的关系，而不能简单的对象群和对象群之间的关系，
				因为对象群与群之间不知道应该如何建立每个对象之间的关系。如果能够隐含建立，那么群与群之间是可以的。
			1. 只有具体的数据对象（RValue）才有可能具体的显示出来，而一般的对象都通过"has"关系和其它对象关联。
				比如，学生有姓名，那么就是某个学生对象和某个名字对象之间建立了“has”关系。
			1. 画面上显示名字的这个列，应该和“名字”这个对象相关联。
				当名字对象的值发生了变化后，则会通知显示名字的控件，而显示名字的控件如果修改了，则修改对应的名字对象的值。
			1. 如果班级和学生的关系发生变化，则监视这个关系的控件（list）就会根据情况进行修改，如果画面针对班级和学生关系进行了修改，
				则会修改对应的班级和此学生之间的关系。
	1. 如果每个数据使用各自的数据类型（整数、浮点数等）和结构（比如树形、列表等），那么接收者如何处理？
		内容可以用字符串来代替，但是数据结构怎么办？没有统一的数据类型，就无法进行高速度的解析和处理。
		可以都假定为列表，或者用一个类型描述符号。
		现在想：如果用最原始类型Data作为基本数据，然后配上数据结构（用迭代器或者特定遍历接口），可以实现目前复杂的数据传递。
    	但是，对于复杂的对象结构，这个怎么从这个对象结构中产生Data的数据结构？
	1. 如果都采用通用数据结构（比如都是tree+文本），但是一定满足所有的需要吗？如果具有特定的数据结构怎么办？比如处理命令参数用的map类型，用树形就无法表达。
		可以考虑低层次的数据结构只是高级数据结构的一个特例（或者子集），这样所有的对象都应该能够尽量兼容最高级的数据结构。
		网(有回路，TODO 这个不好显示！） > 树(没有回路的网) > 表(只有一层的树) > map(单行的表）> 列表/数组/链表(数字作为Key的Map) > 单元素（相当于一个元素的列表）
		比如列表控件最高支持列表，如果传入树，就按照第一层树的子来显示。
	1. 什么时候读取这些数据？可以在传出时，发出一个备份（这样避免数据在使用中时，指向的数据被修改），虽然有可能浪费性能，但是避免了数据出现意外修改的问题。
	1. 不过考虑到数据本身并不是按照数据结构来组织的，可能具有其天然的复杂关系，而使用这个数据的有很多，如果针对这个数据做特殊的处理，
		会造成其他使用者无法使用，所以可以通过“添加数据结构中间层”，来解决这个问题。每个使用这个数据的对象，都建立一个临时的数据结构关联这个数据。
		data <- view 变成 data <- 数据结构 <- view
1. 类型的问题：
	1. 大部分的语言都有类型，是一类对象结构和动作的模板，这里也需要。
	1. 可以建立静态的类型，就是在编译时，将对象的结构和动作都定下来，也可以是动态的，在运行时再通过特殊的处理复制等动作，根据样例对象（就是类型）来生成。
	
# 问题：
1. 对于关系来说，有必要可以作为一个数据吗？比如加法，是否输出就是它本身？还是需要做一个假的输出？
1. 关系发生改变后，应该抛出什么样的修改事件和数据？是否能够和数据的改变事件保持一致？
	关系的改变，发出修改的类型：添加、删除、改变，而辅助数据则是被修改的对象引用。
	TODO 关系，应该也由简单的关系组成，这样其他的对象就能够分析，和复杂的数据结构一样。
	1. 从UML来的，包含数据关系，引用关系，继承关系，调用关系等。
		无论什么关系，最终都变成继承和包含关系（引用、包含、调用等）。继承是静态的关系，
		在有些语言中，变成了只要有对应的属性和方法，就是继承了，而继承在是“照着模板创建”的意思。
		而包含关系则是，对象持有另外一个对象的引用。成组包含的关系也有，
			1. 可以变成一个关系包含一组关系，其中每个关系都是一个包含关系。这里就出现了关系包含关系。
			1. 或者一组关系具有相同的名字，

1. 关系的改变和监视问题
    1. 关系并不是各自开发的，而是根据基本的关系和映射来组合成的。
        1. 如果每个关系都是定制的，那么就无法让其他通用的对象来解析，必须做成组合的形式，这样由通用的子关系组成，那么还有可能被通用对象解析。
    1. 最基本的关系经过总结，包括最基本的关系和组合这些关系的关系。
        1. 分析这些基本关系需要很小心，而且重点是需要达到实用基本的灵活性，这样以后才能够避免自行定义关系的出现。
        1. 另外，不光要找到基本的关系，比如引用，还要找到组合这些关系的基本关系，比如包含等，这样才能够灵活的组合。
    1. 关系发生了改变都包括哪些？
        1. 关系只会有三种情况：创建、销毁、改变。
        1. 对象可以监视某个对象的某个不存在的关系，当这个关系建立时，也能够通知监视者。 销毁容易理解。
        1. 改变，并不是说根据关系维持的对象发生了改变，而是指某个名字的关系，从A关系变成了B关系，
            其实我思考这样的改变可以用创建和销毁来表示，而不用再加入这个改变情况。
        1. 传递的数据，应该改变的类型（创建、销毁），然后数据是改变涉及到的关系对象。
    1. 一个对象如何分析复杂的关系。
        1. 比如一个树控件想显示班级学生关系，那么树控件，首先解析“班级和学生”的关系是一个多包含关系，
            就是说班级可以拥有多个学生，基本关系是“拥有”，而“多拥有”关系是可以将多个关系组合成一个关系的关系 。
            所以就有两个关系：拥有和包含。
    1. 对于生成一个对象的模板来说，可以建立新型的关系:“设定某个关系在对象中必须存在”，或者“某个关系在此对象中可有可无”，
        这样通过这种关系，就可以保证对象必须具有某些关系（就是属性或者方法），能够适用于特殊场合。

1. 关系和对象的改变。
    1. 关系首先是一个对象，所以它也应该遵循“对象值改变”的情形，当它代表的对象发生了改变后，可以发出一个修改。
    1. 但是关系是一个特殊的对象，它具有自己特殊的改变，比如关系本身发生了改变。
        1. 可以将关系改变变成关系的创建和删除，这样它没有改变，就可以用“对象和关系”之间的所属来处理。那么关系涉及到内容发生了改变，就变成了关系本身的改变。
        1. 关系必须有输出对象，则关系是关系，数值对象是数值对象，而关系的改变，则发出关系本身的修改。
        1. 关系可以作为一个对象，而关系本身的改变则是建立和删除，和对象统一的建立和删除相关。
        1. 哪种比较好？

# TODO

1. 首先建立最基本的数据类型的实现
 1. 基本关联
  1. 相等
 1. 数字（整数和浮点数）
 1. 数学公式
 1. 字符串
 1. 逻辑值
 1. 逻辑公式

设想：
尽快进入实用化，这样才能够有不断添加新功能和测试的动力，否则很容易不再维护。
第一个设想的场景就是代码分析。
第二个设想的场景是文件检索和文本处理。
 做文件的关联，然后是行和文字的关联。
第三个设想的场景是数据计算。
第四个设想的场景是git管理。
第五个是远程服务。
第六个是画面显示。
 显示在画面中，数据对象和画面对象之间建立关联。
第七个是数据结构。
 做数组、链表、Table和Tree，以及Net。

首先想能够使用
1. 可以建立数据结构。
1. 可以在控制台输入和输出。
1. 可以控制画面。


 
我觉的第二种是正确的，但是应该建立中间的数据结构层，因为对象处理的最好都是业务无关的数据数据结构，
这样才能够重用。
比如：
一个学校中有多个年级，每个年级都有包含的班级，
每个班级都有学生，学校对应每个年级都有对应的课程，每个课程安排老师，而每个班级都有对应的老师，以及相应的时间。

画面上，想建立
1. 列出班级和班级对应的学生的画面。
1. 根据学生查找对应的班级和对应的课程，以及对应的老师。
首先建立学校、年级、班级、老师、学生、课程和时间时间的关系，将它们联系在一起。
然后画面根据检索的条件，找到对应的对象，然后建立关系。
然后对象发生了变化后，关系根据设定，维护应该保持的关系。
